/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	clients/fcoe-client_auto.ycp
 * Package:	Configuration of fcoe-client
 * Summary:	Client for autoinstallation
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * This is a client for autoinstallation. It takes its arguments,
 * goes through the configuration and return the setting.
 * Does not do any changes to the configuration.
 */

/**
 * @param function to execute
 * @param map/list of fcoe-client settings
 * @return map edited settings, Summary or boolean on success depending on called function
 * @example map mm = $[ "FAIL_DELAY" : "77" ];
 * @example map ret = WFM::CallFunction ("fcoe-client_auto", [ "Summary", mm ]);
 */

{

textdomain "fcoe-client";

y2milestone("----------------------------------------");
y2milestone("FcoeClient auto started");

import "FcoeClient";
include "fcoe-client/wizards.ycp";

any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size(WFM::Args()) > 0 && is(WFM::Args(0), string)) {
    func = (string)WFM::Args(0);
    if(size(WFM::Args()) > 1 && is(WFM::Args(1), map))
	param = (map) WFM::Args(1);
}
y2debug("func=%1", func);
y2debug("param=%1", param);

/* Create a summary*/
if(func == "Summary") {
    ret = select(FcoeClient::Summary(), 0, "");
}
/* Reset configuration */
else if (func == "Reset") {
    FcoeClient::Import($[]);
    ret = $[];
}
/* Change configuration (run AutoSequence) */
else if (func == "Change") {
    ret = FcoeClientAutoSequence();
}
/* Import configuration */
else if (func == "Import") {
    ret = FcoeClient::Import(param);
}
/* Return actual state */
else if (func == "Export") {
    ret = FcoeClient::Export();
}
/* Return needed packages */
else if (func == "Packages") {
    ret = FcoeClient::AutoPackages();
}
/* Read current state */
else if (func == "Read") {
    import "Progress";
    boolean progress_orig = Progress::set (false);
    ret = FcoeClient::Read();
    Progress::set (progress_orig);
}
/* Write given settings */
else if (func == "Write") {
    import "Progress";
    boolean progress_orig = Progress::set (false);

    boolean success = true;
    boolean start_fcoe = false;
    list<map> detected_netcards = [];
    integer index = 0;
    
    // prepare for AutoYaST
    list<map> imported_netcards = FcoeClient::GetNetworkCards();
    y2milestone( "Imported information about netcards: %1", imported_netcards );
    
    // AutoYaST will install package 'open-fcoe' ( checks AutoPackages() ) 

    // Start services 'fcoe' and 'lldpad'
    success = FcoeClient::ServiceStatus();
    if ( success )
    {
	y2milestone( "Services fcoe and lldpad started" );
    }
    else
    {
	y2error( "Cannot start services - stopping auto installation" );
	return false;
    }
    // Reset info about netcards and get current values
    FcoeClient::ResetNetworkCards();
    success = FcoeClient::DetectNetworkCards();
    if ( success )
    {
	detected_netcards = FcoeClient::GetNetworkCards();
	y2milestone( "Information about detected netcards: %1", detected_netcards );
    }
    else
    {
	y2error( "Cannot detect network cards - stopping auto installation" );
	return false;
    }

    // Check imported data
    foreach ( map card, imported_netcards, {
	    if ( card["fcoe_vlan"]:"" != FcoeClient::NOT_AVAILABLE &&
		 card["fcoe_vlan"]:"" != FcoeClient::NOT_CONFIGURED )
	    {
		// any FCoE VLAN interface is configured
		start_fcoe = true;
	    }
	} );
    
    // If any FcoE interface is found in imported data we try to start FCoE
    // for all interfaces which are not yet configured, i.e. where starting of
    // FCoE is possible. We can not start exactly the interface from imported
    // data because the numeration of interfaces (eth0, eth1...) may differ.
    if ( start_fcoe )
    {
	foreach ( map card, detected_netcards, {
		string vlan_interface = "";
		string fcoe_vlan_interface = "";
		string command = "";
		map output = $[];
		string ifcfg_file = "";
		map status_map = $[];
		
		if ( card["fcoe_vlan"]:"" == FcoeClient::NOT_CONFIGURED )
		{
		    ifcfg_file = sformat( "/etc/sysconfig/network/ifcfg-%1\.%2", card["dev_name"]:"",
					  card["vlan_interface"]:"" );
		    // if /etc/sysconfig/network/ifcfg-<vlan-interface> already exists
		    // call 'ifup' for the interface (creates /proc/net/vlan/<vlan-interface>)
		    if ( FileUtils::Exists( ifcfg_file ) ) 
		    {						 
			command = sformat( "ifup %1\.%2", card["dev_name"]:"", card["vlan_interface"]:"" );
			y2milestone( "Executing command: %1", command );
			output = (map)SCR::Execute( .target.bash_output, command );
			y2milestone( "Output: %1", output );

			if ( output["exit"]:255 == 0 )
			{
			    // start FCoE
			    command = sformat( "fipvlan -s %1", card["dev_name"]:"" );
			}
		    }
		    else  // create VLAN interface and start FCoE
		    {
			command = sformat( "fipvlan -c -s %1", card["dev_name"]:"" );
			y2milestone( "Executing command: %1", command );
			output = (map)SCR::Execute( .target.bash_output, command );
			y2milestone( "Output: %1", output );
		    }

		    if ( output["exit"]:255 != 0 )
		    {
			y2error( "Cannot create and start FCoE on %1", card["dev_name"]:"" );
		    }
		    else // get FCoE VLAN interface
		    {
			vlan_interface = FcoeClient::GetVlanInterface( card["dev_name"]:"" );
			if ( vlan_interface == "" )
			{
			    y2error( "VLAN interface not available for %1.", card["dev_name"]:"" );
			}
			else
			{    
			    fcoe_vlan_interface = FcoeClient::GetFcoeVlanInterface( card["dev_name"]:"", 
										    vlan_interface );
			    if ( fcoe_vlan_interface != "" )
			    {
				y2milestone( "FCoE VLAN interface %1 created/started", fcoe_vlan_interface ); 
				// read or create /etc/fcoe/ethx file
				status_map = FcoeClient::GetFCoEStatus( fcoe_vlan_interface );
				// apply modified data
				detected_netcards[ index, "fcoe_vlan"] = fcoe_vlan_interface;
				detected_netcards[ index, "cfg_file"] = status_map["Filename"]:"";
				detected_netcards[ index, "fcoe_enable"] = status_map["FCOE_ENABLE"]:"";
				detected_netcards[ index, "dcb_required"] = status_map["DCB_REQUIRED"]:"";
			    }
			    else
			    {
				y2error( "FCoE VLAN interface not configured for %1", card["dev_name"]:"" );
			    }
			}
		    }
		}
		index = index + 1;
	    });
    }
    y2milestone( "Set NEW information about network cards: %1", detected_netcards );
    // Set new information about netcards
    FcoeClient::SetNetworkCards( detected_netcards );

    // FcoeClient::SetModified(true) is called in FcoeClient::Import(),
    // i.e. modified is set before calling FcoeClient::Write()
    ret = FcoeClient::Write();

    Progress::set (progress_orig);
}
/**
 * did configuration changed
 * return boolean
 */
else if (func == "GetModified") {
    ret = FcoeClient::Modified ();
}
/**
 * set configuration as changed
 * return boolean
 */
else if (func == "SetModified") {
    FcoeClient::SetModified (true);
    ret = true;
}

/* Unknown function */
else {
    y2error("Unknown function: %1", func);
    ret = false;
}

y2debug("ret=%1", ret);
y2milestone("FcoeClient auto finished");
y2milestone("----------------------------------------");

return ret;

/* EOF */
}
