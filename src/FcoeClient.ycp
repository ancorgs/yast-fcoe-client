/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/FcoeClient.ycp
 * Package:	Configuration of fcoe-client
 * Summary:	FcoeClient settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of fcoe-client.
 * Input and output routines.
 */

{

module "FcoeClient";
textdomain "fcoe-client";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Stage";
import "Mode";
import "Package";
import "Popup";
import "Service";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = true;
  }

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}


global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}

/*
  from IscsiClientLib.ycp (line 53) - reading output

  string from_bios = ((map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -m fw"))["stdout"]:"";
  foreach(string row, splitstring(from_bios, "\n"), {
  list<string> key_val=splitstring(row, "=");
//   if (size(key_val[0]:"")>0) ibft[key_val[0]:""] = key_val[1]:"";
   string kv = String::CutBlanks(key_val[0]:"");
   if (size(kv) > 0) ibft[kv] = String::CutBlanks(key_val[1]:"");
   });
 */



// Settings: Define all variables needed for configuration of fcoe-client

// Define all the variables necessary to hold

global integer current_card = 0;  // currently selected card, means row in list of cards

global string NOT_CONFIGURED = "not configured";
global string NOT_AVAILABLE = "not available";

// map containing information about networks cards and VLAN, FCoE and DCB status
map <integer, list> network_interfaces = $[];

// map containing information about values in /etc/fcoe/config
map <string, string> fcoe_general_config = $[ "DEBUG":"no",
					      "USE_SYSLOG":"yes" ];

// list containing information about 'redo' commands
list <string> redo_list = [];

// map containing information about start of services
map <string, boolean> service_start = $[ "fcoe":false,
					 "lldpad":false ];

//
// Check whether open-fcoe is installed and do installation if user agrees
// (dependencies: 'lldpad', 'libhbalinux2' and 'libHBAAPI2') 
//
boolean CheckInstalledPackages()
{
    boolean ret = false;
    
    // don't check interactively for packages (bnc#367300) -> comment from iscsi-client
    // skip it during initial and second stage or when create AY profile
    if(Stage::cont() || Stage::initial() || Mode::config()) return true;
    y2milestone("Check if open-fcoe package installed");

    if( !Package::InstallMsg( "open-fcoe",
			      _("<p>To continue the FCoE configuration, the <b>%1</b> package must be installed.</p>") +
			      _("<p>Install it now?</p>")) )
    {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    }
    else
    {
	ret = true;
    }
    return ret;
}

//
// Check whether a VLAN interface is configured for FCoE on the switch (for given interface)
//
// Params:
// string 	interface	network interface card, e.g. eth3
// Return:
// string	Vlan interface number, e.g. 200
// Example:
// # fipvlan eth3
//Fibre Channel Forwarders Discovered
//interface       | VLAN | FCF MAC          
//------------------------------------------
//eth3            | 200  | 00:0d:ec:a2:ef:00
//
global string GetVlanInterface( string interface )
{
    string vlan_interface = "";

    // check whether there is a VLAN interface which is configured for FCoE
    string cmd_fcoe = sformat( "LANG=POSIX fipvlan %1", interface );
    y2milestone( "Executing command: %1", cmd_fcoe );
    map output = (map)SCR::Execute( .target.bash_output, cmd_fcoe );
    y2milestone( "Output: %1", output );

    list <string> lines = splitstring( output["stdout"]:"", "\n" );
    foreach( string line, (list<string>)lines, {
	    // check whether there is a line for the given interface, e.g.
	    // eth3            | 200  | 00:0d:ec:a2:ef:00\n
	    // and extract name/number of VLAN channel.
	    if ( regexpmatch( line, sformat( "^%1", interface) ) )
	    {
		line = deletechars( line, " " );
		vlan_interface = substring( line, findfirstof( line, "|" )+1,
					    findlastof( line, "|" )-findfirstof( line, "|")-1 );
		y2milestone( "VLAN: %1", vlan_interface );
	    }
	} );
    
    return vlan_interface;
}

//
// Check whether the VLAN device is created (check entries in /proc/net/vlan/config)  
//
// Params:
// string 	interface	network interface card, e.g. eth3
// string 	vlan_interface	Vlan Interface configured for FCoE (on switch)
// Return:
// string	Vlan device name, e.g. eth3.200
// Example:
// # cat /proc/net/vlan/config
//VLAN Dev name    | VLAN ID
//Name-Type: VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD
//eth3.200  | 200  | eth3

global string GetFcoeVlanInterface ( string interface, string vlan_interface )
{
    string vlan_device_name = "";

    string command = sformat( "sed -n 's/\\([^ ]*\\) |.*%1*.*%2/\\1/p' /proc/net/vlan/config",
			       vlan_interface, interface );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output: %1", output );
    // read stdout (remove \n and white spaces)
    vlan_device_name = deletechars( output["stdout"]:"", " \n\t" );
    
    y2milestone( "Returning: %1", vlan_device_name );
    return vlan_device_name;
}

//
// Get status of FCoE and DCB from /etc/fcoe/cfg-eth<vlan_device_name>
//
global map <string, string> GetFCoEStatus( string vlan_device_name )
{
    map <string, string> status_map = $[];
    string content = "";
    
    if ( vlan_device_name != "")
    {
	string file_name = sformat( "/etc/fcoe/cfg-%1", vlan_device_name );
	y2milestone( "VLAN channel %1 found, reading %2", vlan_device_name, file_name );
	content = (string)SCR::Read(.target.string, file_name);

	if ( content == "" || content == nil )
	{
	    // remove '-fcoe' and try again
	    y2milestone( "Reading %1", substring( file_name, 0, size(file_name)-5 ) );
	    content = (string)SCR::Read(.target.string, substring( file_name, 0, size(file_name)-5 ) );
	}
	if ( content == "" || content == nil )
	{
	    y2milestone( "Cannot read cfg-file creating %1 with default values from /etc/fcoe/cfg-ethx",
			 file_name );
	    string def_values = (string)SCR::Read( .target.string, "/etc/fcoe/cfg-ethx" );

	    if ( def_values != "" )
	    {
		boolean ret = SCR::Write( .target.string, file_name, def_values );
		if ( ret == true )
		{
		    status_map = add( status_map, "FCOE_ENABLE", "yes");
		    status_map = add( status_map, "DCB_REQUIRED", "yes");
		}
		else
		{
		    y2error( "Cannot create %1", file_name );
		}
	    }
	    else
	    {
		y2error( "Cannot read /etc/fcoe/cfg-ethx" );
	    }
	    return status_map;
	}
	else
	{
	    y2milestone( "Content: %1", content );
	}
	
	list <string> lines = splitstring( content, "\n" );
	// TODO: better/more elegant way of reading values (use SysConfig agent?)
	foreach( string line, (list<string>)lines, {
		if ( regexpmatch( line, "^FCOE_ENABLE" ) )
		{
		    status_map = add( status_map, "FCOE_ENABLE", deletechars( substring(line, 12), "\"") );
		}
		if ( regexpmatch( line, "^DCB_REQUIRED" ) )
		{
		    status_map = add( status_map, "DCB_REQUIRED", deletechars( substring( line, 13 ),"\"") );
		}
	    });
    }
    else
    {
	y2error( "Interface not valid" );
    }

    return status_map;
}

//
// Check whether the network interface (netcard, e.g. eth0 is DCB capable)
//
string DCBCapable( string netcard )
{
    string ret = "no";

    // 'lldpad' must be started to be able to use 'dcbtool'
    // -> is started in ServiceStatus() ( called in Read() before DetectNetworkCards() ) 
    string command = sformat( "LANG=POSIX dcbtool gc %1 dcb", netcard );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output:  %1", output);
    string status = "";
    
    if ( output["exit"]:255 == 0 )
    {
	list <string> lines = splitstring( output["stdout"]:"", "\n" );
	foreach( string line, (list<string>)lines, {
		if ( regexpmatch( line, "^Status" ) )
		{
		    // Status:         Failed		interface not DCB capable
		    // Status:         Successful
		    line = deletechars ( line, " \t:" );
		    status = substring( line, 6 );
		    y2milestone( "Status: %1", status );
		} } );
	if ( status == "Successful" )
	{
	    ret = "yes";
	}
    }
    else
    {
	y2error( "Exit code: %1 Error: %2", output["exit"]:255, output["stderr"]:"" );
	// if ( output["stderr"]:"" != "" ) Popup::Error ( output["stderr"]:"" );
    }

    return ret;
}

//
// Set status of services
//
global void AdjustStartStatus( )
{
    y2milestone( "Setting start of /etc/init.d/fcoe to %1", service_start["fcoe"]:false );
    if ( service_start["fcoe"]:false == true )
	Service::Enable("fcoe");	
    else
	Service::Disable("open-fcoe");

    y2milestone( "Setting start of /etc/init.d/lldpad to %1", service_start["lldpad"]:false );
    if ( service_start["lldpad"]:false == true )
	Service::Enable("lldpad");	
    else
	Service::Disable("lldpad");
    
}

global void SetStartStatus( string service, boolean status )
{
    y2milestone( "Setting status of %1 to %2", service, status );
    service_start[ service ] = status;
}

//
// Get status of services
//
void DetectStartStatus()
{
    boolean status = false;
    
    status = Service::Enabled( "fcoe" );
    y2milestone( "Status of fcoe: %1", status );
    service_start = add( service_start, "fcoe", status );

    status = Service::Enabled( "lldpad" );
    y2milestone( "Status of lldpad: %1", status );
    service_start = add( service_start, "lldpad", status );

}

global map<string, boolean> GetStartStatus()
{
    return service_start;
}

global boolean ServiceStatus()
{
    // TODO - check whether loading any modules in Stage::initial() is required
    // (like in IsciClientLib.ycp, line 469 )
    boolean ret = true;
			 
    if ( Service::Status( "fcoe" ) != 0 ) 
    {
	boolean success = Service::Start( "fcoe" );
	if ( success )
	{
	    y2milestone( "FCoE started (/etc/init.d/fcoe start)");
	}
	else
	{
	    y2error( "Cannot start FCoE service - '/etc/init.d/fcoe start' failed" );
	    Popup::Error( "Cannot start FCoE service.
'/etc/init.d/fcoe start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "FCoE service is running");
    }

    if ( Service::Status( "lldpad" ) != 0 ) 
    {
	boolean success = Service::Start( "lldpad" );
	if ( success )
	{
	    y2milestone( "Lldpad started (/etc/init.d/lldpad start)");
	}
	else
	{
	    y2error( "Cannot start service lldpad - '/etc/init.d/lldpad start' failed" );
	    Popup::Error( "Cannot start service lldpad.
'/etc/init.d/lldpad start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "Lldpad service is running");
    }
    return ret;
}

//
// dev_name  device             FCoE VLAN  DCB capable FCoE enable  VLAN  data modified
// eth3      Ethernet card ...  eth3.200   yes/no      yes/no       200   yes/no
// 0	     1                  2          3           4            5     6
//
// Detect network interface cards (hardware probe) and get status  
//
void DetectNetworkCards()
{
    string vlan_interface = "";
    string fcoe_vlan_interface = "";
    string dcb_capable = "";
    
    list <map> netcards = (list<map>)SCR::Read(.probe.netcard);
    y2milestone( "Detected netcards: %1", netcards );
    integer row = 0;
    
    foreach ( map card, netcards, {
	    list info_list = [];
	    map <string, string> status_map = $[];

	    vlan_interface = GetVlanInterface( card["dev_name"]:"" );

	    if ( vlan_interface == "" )
	    {
		// FCoE isn't enabled on the switch - we can't do anything here
		fcoe_vlan_interface = NOT_AVAILABLE;
	    }
	    else
	    {
		fcoe_vlan_interface = GetFcoeVlanInterface( card["dev_name"]:"", vlan_interface );

		if ( fcoe_vlan_interface != "" )
		{
		    status_map = GetFCoEStatus( fcoe_vlan_interface );
		}
		else
		{
		    // FCoE VLAN interface not yet configured
		    fcoe_vlan_interface = NOT_CONFIGURED;
		}
	    }
	    
	    dcb_capable = DCBCapable( card["dev_name"]:"" );
	    
	    info_list = add( info_list, card["dev_name"]:"");	// network card, e.g. eth3
	    info_list = add( info_list, card["device"]:"");     // description
	    info_list = add( info_list, fcoe_vlan_interface );	// FCoE VLAN interface, e.g. eth3.200
	    info_list = add( info_list, dcb_capable );		// DCB capable
	    info_list = add( info_list, status_map["FCOE_ENABLE"]:"");
	    info_list = add( info_list, status_map["DCB_REQUIRED"]:"");
	    info_list = add( info_list, vlan_interface );	// VLAN interface, e.g. 200
	    info_list = add( info_list, "no" );		// data not modified
	    network_interfaces = add( network_interfaces, row, info_list );
	    row = row + 1;
	} );
}

//
// Returns the map containing all detected interfaces including
// configuration status of VLAN, FCoE and DCB
//
global map <integer, list> GetNetworkCards()
{
    return network_interfaces;
}

global list <string> GetCurrentNetworkCard()
{
    return (list <string>)network_interfaces[ current_card ]:[];
}

global void SetNetworkCardsValue( integer row, list card )
{
    network_interfaces[row] = card;
}

//
// Read /etc/fcoe/config
//
void ReadFcoeConfig()
{
    list <string> options = (list<string>) SCR::Dir(.fcoe);
    y2milestone( "List of options: %1", options );
    // TODO take values from list
    if ( options != [] )
    {	
	string debug_val = (string)SCR::Read(add(.fcoe, "DEBUG"));
	fcoe_general_config = add( fcoe_general_config, "DEBUG", debug_val );
	
	string syslog_val = (string)SCR::Read(add(.fcoe, "USE_SYSLOG"));
	fcoe_general_config = add( fcoe_general_config, "USE_SYSLOG", syslog_val );
    }
    else
    {
	y2error( "Cannot read /etc/fcoe/config" ); 
    }
}

//
// Set value in fcoe_general_config
//
global void SetFcoeConfigValue( string param, string value )
{
    fcoe_general_config[ param ] = value; 
}

//
// Returns the map containing general FCoE configuration
//
global map <string, string> GetFcoeConfig()
{
    return fcoe_general_config;
}

//
// Add a command to the list of redo commands
//
global void AddRedoCommand( string command )
{
    redo_list = add( redo_list, command );
    y2milestone( "Adding redo command: %1", command );
}

//
// Get the list of redo commands
//
global list GetRedoCommands()
{
    return redo_list;
}

boolean WriteFcoeConfig()
{
    boolean ret = true;
    
    boolean success = (boolean)SCR::Write(add(.fcoe, "DEBUG"), GetFcoeConfig()["DEBUG"]:"" );
    if ( !success )
	ret = false;

    success = (boolean)SCR::Write(add(.fcoe, "USE_SYSLOG"), GetFcoeConfig()["USE_SYSLOG"]:"" );	
    if ( !success )
	ret = false;

    // This is very important- it flushes the cache, and stores the configuration on the disk
    SCR::Write(.fcoe, nil);

    return ret;
}

/**
 * Read all fcoe-client settings
 * @return true on success
 */
global boolean Read()
{

    /* FcoeClient read dialog caption */
    string caption = _("Initializing fcoe-client Configuration");

    // Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
					 /* Progress stage 1/3 */
					 _("Check installed packages"),
					 /* Progress stage 2/3 */
					 _("Check services"),
					 /* Progress stage 3/3 */
					 _("Detect network cards"),
					 /* Progress stage 4/4 */
					 _("Read /etc/fcoe/config" )
					 ], [
					     /* Progress step 1/3 */
					     _("Checking for installed packages..."),
					     /* Progress step 2/3 */
					     _("Checking for services..."),
					     /* Progress step 3/3 */
					     _("Detecting network cards..."),
					     /* Progress step 4/4 */
					     _("Reading /etc/fcoe/config" ),
					     /* Progress finished */
					     _("Finished")
					     ],
		   ""
		   );

    // TODO - is this check needed here (like in IsciClient.ycp)
    // if(!NetworkService::RunningNetworkPopup()) return false;
     
    if(Abort()) return false;
    Progress::NextStage();

    // checking whether open-fcoe is installed (requires lldpad, ...)
    boolean installed = CheckInstalledPackages();
    
    /* Error message */
    if( !installed ) return false;
    sleep(sl);

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    // check whether auto start of daemon fcoemon and lldpad is enabled or not
    DetectStartStatus();
    // check whether fcoe and lldpad are running and start services if required
    boolean start_status = ServiceStatus();
    
    /* Error message */
    if(!start_status) Report::Error(_("Starting of services failed"));
    sleep(sl);

    if(Abort()) return false;
    Progress::NextStage();

    // detect netcards - TODO return value
    DetectNetworkCards();
    
    /* Error message */
    if(false) Report::Warning(_("Cannot detect devices."));
    sleep(sl);

    // read general FCoE settings
    if(Abort()) return false;
    Progress::NextStage();

    // check daemon fcoemon and lldpad
    ReadFcoeConfig();
    
    /* Error message */
    if(false) Report::Error(_("Checking for services failed"));
    sleep(sl);
    
    Progress::Finish();
    
    if(Abort()) return false;
    modified = false;

    return true;
}

/**
 * Write all fcoe-client settings
 * @return true on success
 */
global boolean Write()
{

    /* FcoeClient read dialog caption */
    string caption = _("Saving fcoe-client Configuration");
    y2milestone( "Saving fcoe-client Configuration" );
    
    // Set the number of stages
    integer steps = 2;

    integer sl = 500;
    
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
					/* Progress stage 1/2 */
					_("Write the settings"),
					/* Progress stage 2/2 */
					_("Adjust start of services")
					], [
					    /* Progress step 1/2 */
					    _("Writing the settings..."),
					    /* Progress step 2/2 */
					    _("Adjusting start of services..."),
					    /* Progress finished */
					    _("Finished")
					    ],
		  ""
		  );
    boolean is_running = Progress::IsRunning();
    y2milestone( "**** Progress still running: %1", is_running );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    boolean success = WriteFcoeConfig();
    
    /* Error message */
    if( !success ) Report::Error (_("Cannot write settings to /etc/fcoe/config."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    AdjustStartStatus();
    
    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

    if(Abort()) return false;

    return true;
}

/**
 * Get all fcoe-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings)
{
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the fcoe-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export ()
{
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary()
{
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
