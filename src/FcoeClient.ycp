/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/FcoeClient.ycp
 * Package:	Configuration of fcoe-client
 * Summary:	FcoeClient settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of fcoe-client.
 * Input and output routines.
 */

{

module "FcoeClient";
textdomain "fcoe-client";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Stage";
import "Mode";
import "Package";
import "Popup";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = true;
  }

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}


global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}


// Settings: Define all variables needed for configuration of fcoe-client

// Define all the variables necessary to hold

global string NOT_CONFIGURED = "not configured";

// map containing information about networks cards and VLAN, FCoE aand DCB status
map <integer, list> network_interfaces = $[];

// map containing information about values in /etc/fcoe/config
map <string, string> fcoe_general_config = $[];

//
// Check whether open-fcoe is installed and do installation if user agrees
// (dependencies: 'lldpad', 'libhbalinux2' and 'libHBAAPI2') 
//
boolean CheckInstalledPackages()
{
    boolean ret = false;
    
    // don't check interactively for packages (bnc#367300)
    // skip it during initial and second stage or when create AY profile
    if(Stage::cont() || Stage::initial() || Mode::config()) return true;
    y2milestone("Check if open-fcoe package installed");

    if( !Package::InstallMsg( "open-fcoe",
			      _("<p>To continue the FCoE configuration, the <b>%1</b> package must be installed.</p>") +
			      _("<p>Install it now?</p>")) )
    {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    }
    else
    {
	ret = true;
    }
    return ret;
}


//
// Check whether a VLAN interface is configured for a given network interface 
//
string GetVlanInterface ( string interface )
{
    string vlan_interface = "";
    string command = sformat( "sed -n 's/\\([^ ]*\\) *.*%1/\\1/p' /proc/net/vlan/config",
			      interface );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    // read stdout (remove \n at the end)
    vlan_interface = substring( output["stdout"]:"", 0, size(output["stdout"]:"") -1 );

    return vlan_interface;
}

//
// Get status of FCoE and DCB from /etc/fcoe/cfg-eth<vlan_interface
//
map <string, string> GetFCoEStatus( string vlan_interface )
{
    map <string, string> status_map = $[];
    
    if ( vlan_interface != "")
    {
	string file_name = sformat( "/etc/fcoe/cfg-%1", vlan_interface );
	y2milestone( "VLAN channel %1 found, reading %2", vlan_interface, file_name );

	string content = (string)SCR::Read(.target.string, file_name);
	if ( content == "" )
	    y2warning( "Cannot read %1", file_name );
	else
	    y2milestone( "Content: %1", content );

	list <string> lines = splitstring( content, "\n" );

	foreach( string line, (list<string>)lines, {
		if ( regexpmatch( line, "^FCOE_ENABLE" ) )
		{
		    status_map = add( status_map, "FCOE_ENABLE", substring( line, 12 ) );
		}
		if ( regexpmatch( line, "^DCB_REQUIRED" ) )
		{
		    status_map = add( status_map, "DCB_REQUIRED", substring( line, 13 ) );
		}
	    });
    }
    else
    {
	y2error( "Interface not valid" );
    }

    return status_map;
}

//
// Check whether the network interface (netcard, e.g. eth0 is DCB capable)
//
string DCBCapable( string netcard )
{
    string ret = "no";
    
    string command = sformat( "LANG=POSIX dcbtool gc %1 dcb", netcard );
    y2milestone( "Executing command: %1", command );

    // TODO: lldpad must be started to be able to use dcbtool
    //       -> started in CheckServices() -> Read()
    //          ACHTUNG: Reihenfolge !!!#
    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output:  %1", output);
    string status = "";
    
    if ( output["exit"]:255 == 0 )
    {
	list <string> lines = splitstring( output["stdout"]:"", "\n" );
	foreach( string line, (list<string>)lines, {
		if ( regexpmatch( line, "^Status" ) )
		{
		    // Status:         Failed		interface not DCB capable
		    // Status:         Successful
		    status = substring( line, 16 );
		} } );
	if ( status == "Successful" )
	{
	    ret = "yes";
	}
    }
    else
    {
	y2error( "Error: %1", output["stderr"]:"" );
	Popup::Error ( output["stderr"]:"" );
    }

    return ret;
}

//
// Detect network interface cards (hardware probe) and get status  
//
void DetectNetworkCards()
{
    string vlan_interface = "";
    string dcb_capable = "";
    
    list <map> netcards = (list<map>)SCR::Read(.probe.netcard);
    y2milestone( "Detected netcards: %1", netcards );
    integer row = 0;
    
    foreach ( map card, netcards, {
	    list info_list = [];
	    map <string, string> status_map = $[];
	    
	    vlan_interface = GetVlanInterface( card["dev_name"]:"" );
	    if ( vlan_interface != "" )
		status_map = GetFCoEStatus( vlan_interface );
	    else
		vlan_interface = NOT_CONFIGURED;

	    dcb_capable = DCBCapable( card["dev_name"]:"" );
	    
	    info_list = add( info_list, card["dev_name"]:"");
	    info_list = add( info_list, card["device"]:"");
	    info_list = add( info_list, vlan_interface );
	    info_list = add( info_list, dcb_capable );
	    info_list = add( info_list, status_map["FCOE_ENABLE"]:"");
	    info_list = add( info_list, status_map["DCB_REQUIRED"]:"");
	    
	    network_interfaces = add( network_interfaces, row, info_list );
	    row = row + 1;
	} );
}

//
// Returns the map containing all detected interfaces including
// configuration status of VLAN, FCoE and DCB
//
global map <integer, list> GetNetworkCards()
{
    return network_interfaces;
}

//
// Returns the map containing general FCoE configuration
//
global map <string, string> GetFcoeConfig()
{
    return fcoe_general_config;
}

/**
 * Read all fcoe-client settings
 * @return true on success
 */
global boolean Read()
{

    /* FcoeClient read dialog caption */
    string caption = _("Initializing fcoe-client Configuration");

    // Set the right number of stages
    integer steps = 3;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
					 /* Progress stage 1/3 */
					 _("Check installed packages"),
					 /* Progress stage 2/3 */
					 _("Detect network cards"),
					 /* Progress stage 3/3 */
					 _("Check services")
					 ], [
					     /* Progress step 1/3 */
					     _("Checking for installed packages..."),
					     /* Progress step 2/3 */
					     _("Detecting network cards..."),
					     /* Progress step 3/3 */
					     _("Checking for services..."),
					     /* Progress finished */
					     _("Finished")
					     ],
		   ""
		   );

    // read database
    if(Abort()) return false;
    Progress::NextStage();

    boolean installed = CheckInstalledPackages();
    
    /* Error message */
    if( !installed ) return false;
    sleep(sl);

    // read current settings
    if(Abort()) return false;
    Progress::NextStage();

    DetectNetworkCards();

    /* Error message */
    if(false) Report::Error(_("Cannot get information about netcards"));
    sleep(sl);

    // detect devices
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Warning(_("Cannot detect devices."));
    sleep(sl);

    Progress::Finish();
    
    if(Abort()) return false;
    modified = false;

    return true;
}

/**
 * Write all fcoe-client settings
 * @return true on success
 */
global boolean Write()
{

    /* FcoeClient read dialog caption */
    string caption = _("Saving fcoe-client Configuration");
    y2milestone( "Saving fcoe-client Configuration" );
    
    // Set the number of stages
    integer steps = 2;

    integer sl = 500;
    
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
					/* Progress stage 1/2 */
					_("Write the settings"),
					/* Progress stage 2/2 */
					_("Run SuSEconfig")
					], [
					    /* Progress step 1/2 */
					    _("Writing the settings..."),
					    /* Progress step 2/2 */
					    _("Running SuSEconfig..."),
					    /* Progress finished */
					    _("Finished")
					    ],
		  ""
		  );
    boolean is_running = Progress::IsRunning();
    y2milestone( "**** Progress still running: %1", is_running );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();

    /* Error message */
    if(false) Report::Error (_("Cannot write settings."));
    sleep(sl);

    // run SuSEconfig
    if(Abort()) return false;
    Progress::NextStage ();

    /* Error message */
    if(false) Report::Error (Message::SuSEConfigFailed());
    sleep(sl);

    if(Abort()) return false;

    return true;
}

/**
 * Get all fcoe-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings)
{
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the fcoe-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export ()
{
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary()
{
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
