/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/FcoeClient.ycp
 * Package:	Configuration of fcoe-client
 * Summary:	FcoeClient settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of fcoe-client.
 * Input and output routines.
 */

{

module "FcoeClient";
textdomain "fcoe-client";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Stage";
import "Mode";
import "Package";
import "Popup";
import "Service";
import "NetworkService";
import "String";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug( "get modified = %1", modified );
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
    y2debug( "set modified to %1", value );
    modified = value;
}

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}

global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}

/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    // Do not check UI when running in CommandLine mode
    if (Mode::commandline())
	return false;

    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}

/*
  from IscsiClientLib.ycp (line 53) - reading output

  string from_bios = ((map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -m fw"))["stdout"]:"";
  foreach(string row, splitstring(from_bios, "\n"), {
  list<string> key_val=splitstring(row, "=");
//   if (size(key_val[0]:"")>0) ibft[key_val[0]:""] = key_val[1]:"";
   string kv = String::CutBlanks(key_val[0]:"");
   if (size(kv) > 0) ibft[kv] = String::CutBlanks(key_val[1]:"");
   });
 */


// Define all the variables necessary to hold

global integer current_card = 0;  // currently selected card, means row in list of cards

global string NOT_CONFIGURED = "not configured";
global string NOT_AVAILABLE = "not available";

global boolean lldpad_started = false;	// service fcoe was started
global boolean fcoe_started = false;	// service lldpad was started

global string ifcfg_file = "";

// Settings: Define all variables needed for configuration of fcoe-client

// map containing information about values in /etc/fcoe/config
map <string, string> fcoe_general_config = $[ "DEBUG":"no",
					      "USE_SYSLOG":"yes" ];

// Set value in fcoe_general_config
global void SetFcoeConfigValue( string param, string value )
{
    fcoe_general_config[ param ] = value; 
}

// Returns the map containing general FCoE configuration
global map <string, string> GetFcoeConfig()
{
    return fcoe_general_config;
}

// list containing information about commands to revert changes
list <string> revert_list = [];

// Add a command to the list of revert commands
global void AddRevertCommand( string command )
{
    revert_list = add( revert_list, command );
    y2milestone( "Adding revert command: %1", command );
}

// Get the list of revert commands
global list GetRevertCommands()
{
    return revert_list;
}

// Reset list of revert commands
global void ResetRevertCommands()
{
    revert_list = [];
}

// map containing information about start of services at boot
map <string, boolean> service_start = $[ "fcoe":true,
					 "lldpad":true ];

// map containing information about networks cards and VLAN, FCoE and DCB status
list <map> network_interfaces = [];

// Returns the map containing all detected interfaces including
global list <map> GetNetworkCards()
{
    return network_interfaces;
}

// Get currently selected network card
global map GetCurrentNetworkCard()
{
    return network_interfaces[current_card]:$[];
}

// Set network card values for given row
global void SetNetworkCardsValue( integer row, map card )
{
    network_interfaces[row] = card;
}

global void SetNetworkCards( list<map> netcards )
{
    network_interfaces = netcards;
}

// Reset list of detected cards
global void ResetNetworkCards()
{
    network_interfaces = [];
}

//
// Check whether open-fcoe is installed and do installation if user agrees
// (dependencies: 'lldpad', 'libhbalinux2' and 'libHBAAPI2') 
//
boolean CheckInstalledPackages()
{
    boolean ret = false;
    
    // don't check interactively for packages (bnc#367300) -> comment from iscsi-client
    // skip it during initial and second stage or when create AY profile
    if(Stage::cont() || Stage::initial() || Mode::config()) return true;
    y2milestone("Check if open-fcoe package installed");

    if( !Package::InstallMsg( "open-fcoe",
			      _("<p>To continue the FCoE configuration, the <b>%1</b> package must be installed.</p>") +
			      _("<p>Install it now?</p>")) )
    {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    }
    else
    {
	ret = true;
    }
    return ret;
}

//
// Check whether a VLAN interface is configured for FCoE on the switch (for given interface)
//
// Params:
// string 	interface	network interface card, e.g. eth3
// Return:
// string	Vlan interface number, e.g. 200
// Example:
// # fipvlan eth3
//Fibre Channel Forwarders Discovered
//interface       | VLAN | FCF MAC          
//------------------------------------------
//eth3            | 200  | 00:0d:ec:a2:ef:00
//
global string GetVlanInterface( string interface )
{
    string vlan_interface = "";
    map output = $[];
    
    // check whether there is a VLAN interface which is configured for FCoE
    string cmd_fcoe = sformat( "LANG=POSIX fipvlan %1", interface );
    y2milestone( "Executing command: %1", cmd_fcoe );
    output = (map)SCR::Execute( .target.bash_output, cmd_fcoe );
    y2milestone( "Output: %1", output );

    list <string> lines = splitstring( output["stdout"]:"", "\n" );
    foreach( string line, (list<string>)lines, {
	    // check whether there is a line for the given interface, e.g.
	    // eth3            | 200  | 00:0d:ec:a2:ef:00\n
	    // and extract name/number of VLAN channel.
	    if ( String::StartsWith( line, interface ) )
	    {
		line = deletechars( line, " \t" );
		vlan_interface = substring( line, findfirstof( line, "|" )+1,
					    findlastof( line, "|" )-findfirstof( line, "|")-1 );
		y2milestone( "VLAN: %1", vlan_interface );
	    }
	} );
    
    return vlan_interface;
}

//
// Check whether the VLAN device is created (check entries in /proc/net/vlan/config)  
//
// Params:
// string 	interface	network interface card, e.g. eth3
// string 	vlan_interface	Vlan Interface configured for FCoE (on switch)
// Return:
// string	Vlan device name, e.g. eth3.200
// Example:
// # cat /proc/net/vlan/config
//VLAN Dev name    | VLAN ID
//Name-Type: VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD
//eth3.200  | 200  | eth3

global string GetFcoeVlanInterface ( string interface, string vlan_interface )
{
    string vlan_device_name = "";

    string command = sformat( "sed -n 's/\\([^ ]*\\) *.*%1*.*%2/\\1/p' /proc/net/vlan/config",
			       vlan_interface, interface );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output: %1", output );
    // read stdout (remove \n and white spaces)
    vlan_device_name = deletechars( output["stdout"]:"", " \n\t" );

    if ( vlan_device_name != "" )
    {
	y2milestone( "Returning: %1", vlan_device_name );
    }
    return vlan_device_name;
}

//
// Get status of FCoE and DCB from /etc/fcoe/cfg-eth<vlan_device_name>
//
global map <string, string> GetFCoEStatus( string vlan_device_name )
{
    map <string, string> status_map = $[];
    string content = "";
    boolean file_exists = false;
    
    if ( vlan_device_name != "")
    {
	// fcoemon reads values from /etc/fcoe/cfg-<vlan-interface>, e.g. /etc/fcoe/cfg-eth3.200
	string file_name = sformat( "/etc/fcoe/cfg-%1", vlan_device_name );
	y2milestone( "VLAN channel %1 found, reading %2", vlan_device_name, file_name );

	content = (string)SCR::Read(.target.string, file_name);

	if ( content == "" || content == nil )
	{
	    y2milestone( "Cannot read cfg-file - create %1 (using /etc/fcoe/cfg-ethx) and set AUTO_VLAN to 'no'",
			  file_name );
	    content = (string)SCR::Read( .target.string, "/etc/fcoe/cfg-ethx" );

	    if ( content != "" && content != nil )
	    {
		// bnc #692403: if file name is created with vlan interface in the name
		// (e.g. eth3.200) then set AUTO_VLAN to "no"
		list <string> lines = (list<string>)splitstring( content, "\n" );
		lines = maplist( string line, lines, {
			if ( !String::StartsWith( line, "#" ) )	line = deletechars( line, " \t" );
			     
			if ( String::StartsWith( line, "AUTO_VLAN" ) )
			{
			    return "AUTO_VLAN=\"no\"";
			}
			else
			{
			    return line;
			}
		    });
		content = mergestring( lines, "\n" );
		y2milestone( "Writing content: %1", content );
		
		file_exists = SCR::Write( .target.string, file_name, content );

		if ( file_exists )
		{
		    AddRevertCommand( sformat( "rm %1", file_name ) );
		}
		else
		{
		    y2error( "Cannot create %1", file_name );
		}
	    }
	    else
	    {
		y2error( "Cannot read /etc/fcoe/cfg-ethx" );
	    }
	}
	else
	{
	    file_exists = true;
	    y2milestone( "Content: %1", content );
	}
	
	if ( file_exists )
	{
	    list <string> lines = splitstring( content, "\n" );
	    foreach( string line, (list<string>)lines, {
		    line = deletechars( line, " \t" );
		    foreach( string var, ["FCOE_ENABLE", "DCB_REQUIRED", "AUTO_VLAN"], {
			    if ( String::StartsWith(line, var) )
			    {
				status_map = add( status_map, var,
						  deletechars( substring(line, size(var) + 1), "\"") );
			    }
			});

		});
	    status_map = add( status_map, "Filename", file_name );
	}
    }
    else
    {
	y2error( "Interface not valid" );
    }
    y2milestone( "Returning: %1", status_map );
    
    return status_map;
}

//
// Check whether the network interface (netcard, e.g. eth0 is DCB capable)
//
string DCBCapable( string netcard )
{
    string ret = "no";

    // 'lldpad' must be started to be able to use 'dcbtool'
    // -> is started in ServiceStatus() ( called in Read() before DetectNetworkCards() ) 
    string command = sformat( "LANG=POSIX dcbtool gc %1 dcb", netcard );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output:  %1", output);
    string status = "";
    
    if ( output["exit"]:255 == 0 )
    {
	list <string> lines = splitstring( output["stdout"]:"", "\n" );
	foreach( string line, (list<string>)lines, {
		if ( String::StartsWith( line, "Status" ) )
		{
		    // Status:         Failed		interface not DCB capable
		    // Status:         Successful
		    line = deletechars ( line, " \t:" );
		    status = substring( line, 6 );
		    y2milestone( "Status: %1", status );
		} } );
	if ( status == "Successful" )
	{
	    ret = "yes";
	}
    }
    else
    {
	y2error( "Exit code: %1 Error: %2", output["exit"]:255, output["stderr"]:"" );
	// if ( output["stderr"]:"" != "" ) Popup::Error ( output["stderr"]:"" );
    }

    return ret;
}

//
// Set status of services
//
global void AdjustStartStatus( )
{
    y2milestone( "Setting start of /etc/init.d/boot.fcoe to %1", service_start["fcoe"]:false );
    if ( service_start["fcoe"]:false == true )
	Service::Enable("boot.fcoe");	
    else
	Service::Disable("boot.fcoe");

    y2milestone( "Setting start of /etc/init.d/lldpad to %1", service_start["lldpad"]:false );
    if ( service_start["lldpad"]:false == true )
	Service::Enable("boot.lldpad");	
    else
	Service::Disable("boot.lldpad");
    
}

global void SetStartStatus( string service, boolean status )
{
    y2milestone( "Starting service %1 on boot: %2", service, status );
    service_start[ service ] = status;
}

//
// Get status of services
//
void DetectStartStatus()
{
    boolean status = false;
    
    status = Service::Enabled( "boot.fcoe" );
    y2milestone( "Start status of fcoe: %1", status );
    service_start = add( service_start, "fcoe", status );

    status = Service::Enabled( "boot.lldpad" );
    y2milestone( "Start status of lldpad: %1", status );
    service_start = add( service_start, "lldpad", status );
}

global map<string, boolean> GetStartStatus()
{
    return service_start;
}

//
// Check status of services 'fcoe' and 'lldpad' and start them if required
// 
global boolean ServiceStatus()
{
    // Loading of modules in Stage::initial() is not required (like in IsciClientLib.ycp, line 523 )
    // see /etc/init.d/fcoe, line 85 (modprobe fcoe > /dev/null 2>&1)
    boolean ret = true;
			 
    if ( Service::Status( "boot.fcoe" ) != 0 ) 
    {
	boolean success = Service::Start( "boot.fcoe" );
	if ( success )
	{
	    y2milestone( "FCoE started (/etc/init.d/boot.fcoe start)");
	    fcoe_started = true;;
	}
	else
	{
	    y2error( "Cannot start FCoE service - '/etc/init.d/boot.fcoe start' failed" );
	    Popup::Error( "Cannot start FCoE service.
'/etc/init.d/boot.fcoe start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "FCoE service is running");
    }

    if ( Service::Status( "boot.lldpad" ) != 0 ) 
    {
	boolean success = Service::Start( "boot.lldpad" );
	if ( success )
	{
	    y2milestone( "Lldpad started (/etc/init.d/boot.lldpad start)");
	    lldpad_started = true;
	}
	else
	{
	    y2error( "Cannot start service lldpad - '/etc/init.d/boot.lldpad start' failed" );
	    Popup::Error( "Cannot start service lldpad.
'/etc/init.d/boot.lldpad start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "Lldpad service is running");
    }
    return ret;
}

//
// dev_name  device             fcoe_vlan  fcoe_enable dcb_required auto_vlan dcb_capable vlan_interface	cfg_file
// eth3      Ethernet card ...  eth3.200   yes/no      yes/no       yes/no    yes/no       200   		/etc/fcoe/cfg-eth3.200
//
// Detect network interface cards (hardware probe) and get status  
//
global boolean DetectNetworkCards()
{
    string vlan_interface = "";
    string fcoe_vlan_interface = "";
    string dcb_capable = "";
    
    list <map> netcards = (list<map>)SCR::Read(.probe.netcard);
    y2milestone( "Detected netcards: %1", netcards );

    if ( netcards == [] || netcards == nil )
	return false;

    foreach ( map card, netcards, {
	    // get first (at the moment only) state map from link list in resource map
	    map state_map = card["resource", "link", 0 ]:$[];

	    if ( state_map["state"]:false == false )
	    {
		// call 'ifconfig <interface> up' here because it's not yet
		// clear who configures the interfaces (fipvlan command itself?)
		// -> see bnc #705171 (this applies also to installed system)

		string cmd_ifup = sformat( "ifconfig %1 up", card["dev_name"]:"" );
		y2milestone( "Executing command: %1", cmd_ifup );
		SCR::Execute( .target.bash_output, cmd_ifup );

		// ifconfig up always returns 0 -> no error message can be made
	    }
	} );
    // call .probe.netcard again
    netcards = (list<map>)SCR::Read(.probe.netcard);

    foreach ( map card, netcards, {
	    map state_map = card["resource", "link", 0]:$[];
	    map info_map = $[];
	    map <string, string> status_map = $[];

	    // only call fipvlan <interface> for configured interfaces
	    if ( state_map["state"]:false == true )
	    {
		vlan_interface = GetVlanInterface( card["dev_name"]:"" );
	    }
	    if ( vlan_interface == "" )
	    {
		// FCoE isn't enabled on the switch - we can't do anything here.
		fcoe_vlan_interface = NOT_AVAILABLE;
	    }
	    else
	    {
		fcoe_vlan_interface = GetFcoeVlanInterface( card["dev_name"]:"", vlan_interface );

		if ( fcoe_vlan_interface != "" )
		{
		    status_map = GetFCoEStatus( fcoe_vlan_interface );
		}
		else
		{
		    // FCoE VLAN interface not yet configured
		    fcoe_vlan_interface = NOT_CONFIGURED;
		}
	    }
	    dcb_capable = DCBCapable( card["dev_name"]:"" );
	    
	    info_map = add( info_map, "dev_name", card["dev_name"]:"");		// network card, e.g. eth3
	    info_map = add( info_map, "device", card["device"]:"");		// description
	    info_map = add( info_map, "fcoe_vlan", fcoe_vlan_interface );	// FCoE VLAN interface, e.g. eth3.200
	    info_map = add( info_map, "fcoe_enable", status_map["FCOE_ENABLE"]:"");	// FCOE_ENABLE
	    info_map = add( info_map, "dcb_required", status_map["DCB_REQUIRED"]:""); 	// DCB_REQUIRED
	    info_map = add( info_map, "auto_vlan", status_map["AUTO_VLAN"]:"");	// AUTO_VLAN
	    info_map = add( info_map, "dcb_capable", dcb_capable );		// DCB capable
	    info_map = add( info_map, "vlan_interface", vlan_interface );		// VLAN interface, e.g. 200
	    info_map = add( info_map, "cfg_file", status_map["Filename"]:"" ); 	// cfg file name, e.g. /etc/fcoe/cfg-eth3.200

	    network_interfaces = add( network_interfaces, info_map );
	} );
    // sort the list of interfaces (eth0, eth1, eth2...)
    network_interfaces = sort( map a, map b, network_interfaces, {
		    return ( a["dev_name"]:"" < b["dev_name"]:"" );
		} );
    return true;
}

//
// Read /etc/fcoe/config
//
global boolean ReadFcoeConfig()
{
    list <string> options = (list<string>) SCR::Dir(.fcoe);
    y2milestone( "List of options in /etc/fcoe/config: %1", options );

    if ( options == [] || options == nil )
	return false;
    
    string debug_val = (string)SCR::Read(add(.fcoe, "DEBUG"));
    fcoe_general_config = add( fcoe_general_config, "DEBUG", debug_val );
	
    string syslog_val = (string)SCR::Read(add(.fcoe, "USE_SYSLOG"));
    fcoe_general_config = add( fcoe_general_config, "USE_SYSLOG", syslog_val );

    y2milestone( "/etc/fcoe/config read: DEBUG: %1, USE_SYSLOG: %2", debug_val, syslog_val );
    
    return true;
}

//
// Write /etc/fcoe/config using SCR agent
//
global boolean WriteFcoeConfig()
{
    boolean ret = true;
    
    boolean success = (boolean)SCR::Write(add(.fcoe, "DEBUG"), GetFcoeConfig()["DEBUG"]:"" );
    if ( !success )
	ret = false;

    success = (boolean)SCR::Write(add(.fcoe, "USE_SYSLOG"), GetFcoeConfig()["USE_SYSLOG"]:"" );	
    if ( !success )
	ret = false;

    // This is very important- it flushes the cache, and stores the configuration on the disk
    SCR::Write(.fcoe, nil);

    return ret;
}

//
// Write /etc/fcoe/cfg-ethx files
//
global boolean WriteCfgFiles()
{
    list <map> netcards = GetNetworkCards();
    boolean success = true;
    string command = "";
    map output = $[];
    
    y2milestone( "Writing /etc/fcoe/cfg-ethx files" );
    
    foreach ( map card, (list<map>)netcards, {
	    if ( card["fcoe_vlan"]:"" != FcoeClient::NOT_AVAILABLE &&			// FCoE VLAN is configured
		 card["fcoe_vlan"]:"" != FcoeClient::NOT_CONFIGURED && Modified() )  	// and data are modified 
	    {
		string content = (string)SCR::Read( .target.string, card["cfg_file"]:"" );
		y2debug( "Original content of %1: %2", card["cfg_file"]:"", content );
		
		list <string> lines = (list<string>)splitstring( content, "\n" );
		lines = maplist( string line, lines, {
			if ( !String::StartsWith( line, "#" ) )	 line = deletechars( line, " \t" );

			if ( String::StartsWith( line, "FCOE_ENABLE" ) )
			{
			    return sformat( "FCOE_ENABLE=\"%1\"", card["fcoe_enable"]:"no" );
			}
			else if ( String::StartsWith( line, "DCB_REQUIRED" ) )
			{
			    return sformat( "DCB_REQUIRED=\"%1\"", card["dcb_required"]:"no" );
			}
			else if ( String::StartsWith( line, "AUTO_VLAN" ) )
			{
			    return sformat( "AUTO_VLAN=\"%1\"", card["auto_vlan"]:"no" );
			}
			else
			{
			    return line;
			}
		    });
		content = mergestring( lines, "\n" );
		y2milestone( "Writing content: %1", content );

		boolean ret = SCR::Write( .target.string, card["cfg_file"]:"", content );
		if ( !ret )
		{
		    success = ret;
		    y2error( "Cannot write %1", card["cfg_file"]:"" );
		}
		else
		{
		    y2milestone( "%1 written", card["cfg_file"]:"" );
		}
		// enable DCB app fcoe (app:0)
		if (  card["dcb_required"]:"no" == "yes" )
		{
		    command = sformat( "dcbtool sc %1 app:0 e:1 a:1 w:1", card["dev_name"]:"" );
		    y2milestone( "Executing command: %1", command );

		    output = (map)SCR::Execute( .target.bash_output, command );
		    y2milestone( "Output: %1", output );
		    if ( output["exit"]:255 != 0 )
		    {
			Popup::Error( sformat( _("Command: %1 failed"), command ) );
			y2error( "Command: %1 failed", command);
		    } 
		}
	    }
	} );
    
    return success;
}

global boolean RestartServiceFcoe()
{
    boolean ret = true;
    if ( FcoeClient::Modified() )
    {
	y2milestone( "Restarting fcoe");
	ret = Service::Restart("boot.fcoe");
    }
    return ret;
}

/**
 * Read all fcoe-client settings
 * @return true on success
 */
global boolean Read()
{

    /* FcoeClient read dialog caption */
    string caption = _("Initializing fcoe-client Configuration");

    // Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
					 /* Progress stage 1/3 */
					 _("Check installed packages"),
					 /* Progress stage 2/3 */
					 _("Check services"),
					 /* Progress stage 3/3 */
					 _("Detect network cards"),
					 /* Progress stage 4/4 */
					 _("Read /etc/fcoe/config" )
					 ], [
					     /* Progress step 1/3 */
					     _("Checking for installed packages..."),
					     /* Progress step 2/3 */
					     _("Checking for services..."),
					     /* Progress step 3/3 */
					     _("Detecting network cards..."),
					     /* Progress step 4/4 */
					     _("Reading /etc/fcoe/config" ),
					     /* Progress finished */
					     _("Finished")
					     ],
		   ""
		   );

    // a check for running network services doesn't make sense (is not needed), the
    // interfaces are set up in FcoeClient::GetVlanInterfaces()
     
    if(PollAbort()) return false;
    Progress::NextStage();

    // checking whether open-fcoe is installed (requires lldpad, ...)
    boolean installed = CheckInstalledPackages();
    
    /* Error message */
    if( !installed ) return false;
    sleep(sl);

    // read current settings
    if(PollAbort()) return false;
    Progress::NextStage();

    // check whether auto start of daemon fcoemon and lldpad is enabled or not
    DetectStartStatus();
    // check whether fcoe and lldpad are running and start services if required
    boolean start_status = ServiceStatus();
    
    /* Error message */
    if(!start_status) Report::Error(_("Starting of services failed."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();

    // detect netcards
    boolean success = DetectNetworkCards();
    
    /* Error message */
    if( !success ) Report::Warning(_("Cannot detect devices."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();

    // read general FCoE settings
    success = ReadFcoeConfig();
    
    /* Error message */
    if( !success ) Report::Error(_("Cannot read /etc/fcoe/config."));
    sleep(sl);
    
    Progress::Finish();
    
    if(PollAbort()) return false;
    // modified = false is from CWM template
    modified = false;

    return true;
}

/**
 * Write all fcoe-client settings
 * @return true on success
 */
global boolean Write()
{

    /* FcoeClient read dialog caption */
    string caption = _("Saving fcoe-client Configuration");
    y2milestone( "Saving fcoe-client Configuration" );
    
    // Set the number of stages
    integer steps = 3;

    integer sl = 500;
    
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
					/* Progress stage 1/2 */
					_("Write the settings"),
					/* Progress stage 2/3 */
					_("Restart FCoE service"),
					/* Progress stage 3/3 */
					_("Adjust start of services")
					], [
					    /* Progress step 1/2 */
					    _("Writing the settings..."),
					    /* Progress step 2/3 */
					    _("Restarting FCoE service..."),
					    /* Progress sstep 3/3 */
					    _("Adjusting start of services..."),
					    /* Progress finished */
					    _("Finished")
					    ],
		  ""
		  );

    // iscsi-client prepares for AutoYaST in Mode::autoinst()/autoupgrade()
    // (see IscsiClient.ycp, line 236, 241)
    // These things are done in fcoe-client_auto.ycp (should be sufficient there)
    
    boolean is_running = Progress::IsRunning();
    y2debug( "**** Progress still running: %1", is_running );

    // write settings
    if(PollAbort()) return false;
    Progress::NextStage();
    
    boolean success = WriteFcoeConfig();
    /* Error message */
    if( !success ) Report::Error (_("Cannot write settings to /etc/fcoe/config."));
    sleep(sl);

    success = WriteCfgFiles();
    if( !success ) Report::Error (_("Cannot write settings for FCoE interfaces.
For details see /var/log/YaST2/y2log") );

    // restart fcoe to enable changes 
    if(PollAbort()) return false;
    Progress::NextStage();

    success = RestartServiceFcoe();
     /* Error message */
    if( !success ) Report::Error (_("/etc/init.d/fcoe restart failed."));
    sleep(sl);
    
    // adjust service start of lldpad and fcoe
    if(PollAbort()) return false;
    Progress::NextStage ();

    // adjust start status of services lldpad and fcoe
    AdjustStartStatus();

    // Adding additional package (like in IscsiClient.ycp, line 257)
    // is done in inst_fcoe-client.ycp (PackagesProposal::AddResolvables)
    sleep(sl);

    if(PollAbort()) return false;

    return true;
}

/**
 * Get all fcoe-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings)
{
    // fill variables
    fcoe_general_config = (map <string, string>)settings["fcoe_cfg"]:$[ ];
    network_interfaces = (list <map>)settings["interfaces"]:[];
    service_start = (map <string, boolean>)settings["service_start"]:$[ ];
    
    SetModified( true );
    y2milestone ("Configuration has been imported");

    return true;
}

/**
 * Dump the fcoe-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export ()
{
    // return map containing current settings 
    return $[
             "fcoe_cfg" : fcoe_general_config,
             "interfaces" : network_interfaces,
	     "service_start" : service_start
             ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary()
{
    string summary = "";
    map fcoe_config = $[];
    list <map> netcards = [];
    map service_start = $[];
    
    /* Configuration summary text for autoyast */
    summary = Summary::AddLine( summary, _("<b>General FCoE configuration</b>") );
    fcoe_config = FcoeClient::GetFcoeConfig();
    // options from config file, not meant for translation 
    summary = Summary::AddLine( summary, sformat( "DEBUG: %1", fcoe_config["DEBUG"]:"" ) );
    summary = Summary::AddLine( summary, sformat( "USE_SYSLOG: %1", fcoe_config["USE_SYSLOG"]:"" ) );
    summary = Summary::AddLine( summary, _("<b>Interfaces</b>") );
    netcards = FcoeClient::GetNetworkCards();
    foreach ( map card, netcards, {
	    summary = Summary::AddLine( summary, sformat( "%1: %2 %3: %4",
							  // network card, e.g. eth0
							  _("<i>Netcard</i>:"), card["dev_name"]:"",
							  // nothing to translate here (abbreviation for
							  // Fibre Channel over Ethernet Virtual LAN interface)
							  "<i>FCoE VLAN</i>", card["fcoe_vlan"]:"" ) );
	} );
    service_start = FcoeClient::GetStartStatus();
    summary = Summary::AddLine( summary, _("<b>Starting of services</b>") );
    
    // starting of service "fcoe" at boot time is enabled or disabled
    summary = Summary::AddLine( summary, sformat( "fcoe: %1", (service_start["fcoe"]:false)?_("enabled"):_("disabled") ));
    // starting of service "lldpad" at boot time is enabled or disabled 
    summary = Summary::AddLine( summary, sformat( "lldpad: %1", (service_start["lldpad"]:false)?_("enabled"):_("disabled") ) );
    
    return [ summary, [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    // installation of open-fcoe required
    return $[ "install":["open-fcoe"], "remove":[] ];
}

/* EOF */
}
