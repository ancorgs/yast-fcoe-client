/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/FcoeClient.ycp
 * Package:	Configuration of fcoe-client
 * Summary:	FcoeClient settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of fcoe-client.
 * Input and output routines.
 */

{

module "FcoeClient";
textdomain "fcoe-client";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Stage";
import "Mode";
import "Package";
import "Popup";
import "Service";
import "NetworkService";
import "String";
import "FileUtils";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data
 */

/**
 * data modified?
 */
boolean modified = false;

/**
 * proposal valid?
 */
boolean proposal_valid = false;

/**
 * Number of retries for fipvlan (default is 20).
 * The number is reduced to 10 to make detection faster. 10 seconds (10 retries *
 * 1000 ms) should be enough time for most interfaces. If not there is the
 * possibility to retry interface dedection using 'Retry'.
 */
string number_of_retries = "10";

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/**
 */
boolean test_mode = false;

/**
 * Constructor
 */
global void FcoeClient()
{
    if ( getenv("FCOE_CLIENT_TEST_MODE") == "1" )
    {
        y2milestone( "Running in test mode" );
        test_mode = true;
    }
    else
    {
        test_mode = false;
    }
}

/**
 * Abort function
 * return boolean return true if abort
 */
boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug( "get modified = %1", modified );
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
    y2debug( "set modified to %1", value );
    modified = value;
}

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * @return true if test mode is set (environment variable FCOE_CLIENT_TEST_MODE)
 */
global boolean TestMode()
{
    return test_mode;
}

/**
 * Set write_only flag (for autoinstallation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}

global void SetAbortFunction(boolean() function) {
    AbortFunction = function;
}

/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    // Do not check UI when running in CommandLine mode
    if (Mode::commandline())
	return false;

    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}

/*
  from IscsiClientLib.ycp (line 53) - reading output

  string from_bios = ((map<string, any>)SCR::Execute(.target.bash_output, "iscsiadm -m fw"))["stdout"]:"";
  foreach(string row, splitstring(from_bios, "\n"), {
  list<string> key_val=splitstring(row, "=");
//   if (size(key_val[0]:"")>0) ibft[key_val[0]:""] = key_val[1]:"";
   string kv = String::CutBlanks(key_val[0]:"");
   if (size(kv) > 0) ibft[kv] = String::CutBlanks(key_val[1]:"");
   });
 */


// Define all the variables necessary to hold

global integer current_card = 0;  // currently selected card, means row in list of cards

global string NOT_CONFIGURED = "not configured";
global string NOT_AVAILABLE = "not available";

global boolean lldpad_started = false;	// service fcoe was started
global boolean fcoe_started = false;	// service lldpad was started


// Settings: Define all variables needed for configuration of fcoe-client

// map containing information about values in /etc/fcoe/config
map <string, string> fcoe_general_config = $[ "DEBUG":"no",
					      "USE_SYSLOG":"yes" ];

// Set value in fcoe_general_config
global void SetFcoeConfigValue( string param, string value )
{
    fcoe_general_config[ param ] = value; 
}

// Returns the map containing general FCoE configuration
global map <string, string> GetFcoeConfig()
{
    return fcoe_general_config;
}

// list containing information about commands to revert changes
list <string> revert_list = [];

// Add a command to the list of revert commands
global void AddRevertCommand( string command )
{
    revert_list = add( revert_list, command );
    y2milestone( "Adding revert command: %1", command );
}

// Get the list of revert commands
global list GetRevertCommands()
{
    return revert_list;
}

// Reset list of revert commands
global void ResetRevertCommands()
{
    revert_list = [];
}

// map containing information about start of services at boot
map <string, boolean> service_start = $[ "fcoe":true,
					 "lldpad":true ];

// map containing information about networks cards and VLAN, FCoE and DCB status
list <map> network_interfaces = [];

// Returns the map containing all detected interfaces (possibly including
// several entries for a network interface if several VLAN interfaces are
// detected)
global list <map> GetNetworkCards()
{
    return network_interfaces;
}

// Get currently selected network card
global map GetCurrentNetworkCard()
{
    return network_interfaces[current_card]:$[];
}

// Set network card values for given row
global void SetNetworkCardsValue( integer row, map card )
{
    network_interfaces[row] = card;
}

global void SetNetworkCards( list<map> netcards )
{
    network_interfaces = netcards;
}

// Reset list of detected cards
global void ResetNetworkCards()
{
    network_interfaces = [];
}

//
// Check whether open-fcoe is installed and do installation if user agrees
// (dependencies: 'lldpad', 'libhbalinux2' and 'libHBAAPI2') 
//
boolean CheckInstalledPackages()
{
    boolean ret = false;
    
    // don't check interactively for packages (bnc#367300) -> comment from iscsi-client
    // skip it during initial and second stage or when create AY profile
    if(Stage::cont() || Stage::initial() || Mode::config()) return true;
    y2milestone("Check if open-fcoe package installed");

    if( !Package::InstallMsg( "open-fcoe",
			      _("<p>To continue the FCoE configuration, the <b>%1</b> package must be installed.</p>") +
			      _("<p>Install it now?</p>")) )
    {
        Popup::Error( Message::CannotContinueWithoutPackagesInstalled() );
    }
    else
    {
	ret = true;
    }
    return ret;
}

//
// Check whether VLAN interfaces are configured for FCoE on the switch
//
// Params:
// string 	interface	network interface card, e.g. eth3
// Return:
// string	Vlan interface number, e.g. 200
// Example:
// # fipvlan eth0 eth1 eth2 eth3
//Fibre Channel Forwarders Discovered
//interface       | VLAN | FCF MAC          
//------------------------------------------
//eth0            | 200  | 00:0d:ec:a2:ef:00
//eth3		  | 200  | 00:0d:ec:a2:ef:01
//
global map<string, list> GetVlanInterfaces( list net_devices )
{
    // Add option -u (or --link_up): don't shut down interfaces
    // to be able to detect DCB state afterwards (see bnc #737683)
    string vlan_cmd = "LANG=POSIX fipvlan -u";
    map<string, list> vlan_info = $[];

    if ( !Mode::autoinst() )
        vlan_cmd = vlan_cmd + " -l " + FcoeClient::number_of_retries;      // reduce number of retries 

    foreach ( string dev, (list<string>)net_devices, {
	    vlan_cmd = vlan_cmd + " " + dev;
	} );
    
    // call fipvlan command for all interfaces (saves time because is executed in parallel)
    y2milestone( "Executing command: %1", vlan_cmd );
    map output = (map)SCR::Execute( .target.bash_output, vlan_cmd );
    y2milestone( "Output: %1", output );

    list <string> lines = [];
    if ( !TestMode() )
    {
        lines = splitstring( output["stdout"]:"", "\n" );
    }
    else        // test data
    {
        lines = splitstring("Fibre Channel Forwarders
< Discovered\ninterface       | VLAN | FCF MAC
< \n------------------------------------------\neth15           | 2011 |54:7f:ee:04:55:9f\neth15           | 0    | 54:7f:ee:04:55:9f\neth15           | 200    | 54:7f:ee:04:55:9f\neth1           | 301 |54:7f:ee:04:55:9f\neth1           | 400 |54:7f:ee:04:55:9f\n\n", "\n");
    }

    foreach ( string dev, (list<string>)net_devices, {
	    foreach( string line, (list<string>)lines, {
		    // check whether there is a line for the given interface, e.g.
		    // eth3            | 200  | 00:0d:ec:a2:ef:00\n
		    // and get VLAN channel from second columns.
                    line = deletechars( line, " \t" );
                    list<string> columns = splitstring( line, "|" );
		    if ( columns[0]:"" == dev )
		    {
			string vlan_interface = columns[1]:"";
			y2milestone( "Interface: %1 VLAN: %2", dev, vlan_interface );

                        if ( vlan_info[dev]:[] == [] )
                        {
                            vlan_info = add( vlan_info, dev, [vlan_interface] );
                        }
                        else
                        {
                            list vlans = vlan_info[dev]:[];
                            vlans = add( vlans, vlan_interface );
                            vlan_info[dev] = vlans;
                        }
                        // overwrite existing entry if VLAN = 0 is found (see bnc #813621)
                        //if ( vlan_info[dev]:"" == "" || vlan_interface == "0" )
                        //{
                        //    vlan_info = add( vlan_info, dev, vlan_interface );
                        //}
		    }
		} );
	} );
    y2milestone( "VLAN info: %1", vlan_info );
    return vlan_info;
}

//
// Check whether the VLAN device is created (check entries in /proc/net/vlan/config)  
//
// Params:
// string 	interface	network interface card, e.g. eth3
// string 	vlan_interface	Vlan Interface configured for FCoE (on switch)
// Return:
// string	Vlan device name, e.g. eth3.200
// Example:
// # cat /proc/net/vlan/config
//VLAN Dev name    | VLAN ID
//Name-Type: VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD
//eth3.200  | 200  | eth3

global string GetFcoeVlanInterface ( string interface, string vlan_interface )
{
    string vlan_device_name = "";

    if ( TestMode() && vlan_interface != "2011" )
        return interface + "." + vlan_interface;

    string command = sformat( "sed -n 's/\\([^ ]*\\) *.*%1*.*%2/\\1/p' /proc/net/vlan/config",
			       vlan_interface, interface );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output: %1", output );
    // read stdout (remove \n and white spaces)
    vlan_device_name = deletechars( output["stdout"]:"", " \n\t" );

    if ( vlan_device_name != "" )
    {
	y2milestone( "Returning: %1", vlan_device_name );
    }
    else
    {
        y2error( "FCoE VLAN not found in /proc/net/vlan/config" );
    }
    return vlan_device_name;
}

//
// Create /etc/fcoe/cfg-<if> or /etc/fcoe/cfg-<if>.<vlan>
// (depending on AUTO_VLAN setting)
//
global map<string, string> CreateFcoeConfig( string vlan_device_name, map netcard )
{
    string file_name = "";
    string device_name = "";
    boolean file_exists = false;
    map <string, string> status_map = $[];
 
    // if AUTO_VLAN is set to "yes" or VLAN is set to "0" (means no VLAN created but FCoE started on device)
    if ( netcard["auto_vlan"]:"no" == "yes" || netcard["vlan_interface"]:"" == "0" )
    {
        device_name = netcard["dev_name"]:"";
	// set file name to cfg-<interface>, e.g. /etc/fcoe/cfg-eth3
	file_name = sformat( "/etc/fcoe/cfg-%1", device_name );
    }
    else
    {
        device_name = vlan_device_name;
	// set file name to cfg-<vlan_device_name>, e.g. /etc/fcoe/cfg-eth3.200
	file_name = sformat( "/etc/fcoe/cfg-%1", vlan_device_name );
    }
    
    // read default values
    string content = (string)SCR::Read( .target.string, "/etc/fcoe/cfg-ethx" );

    // and prepare content 
    if ( content != "" && content != nil )
    {
	list <string> lines = (list<string>)splitstring( content, "\n" );
	lines = maplist( string line, lines, {
		if ( !String::StartsWith( line, "#" ) )	line = deletechars( line, " \t" );
			     
		if ( String::StartsWith( line, "AUTO_VLAN" ) )
		{
		    return sformat( "AUTO_VLAN=\"%1\"", netcard["auto_vlan"]:"no" );
		}
		else if ( String::StartsWith( line, "DCB_REQUIRED" ) )
		{
		    return sformat( "DCB_REQUIRED=\"%1\"", netcard["dcb_required"]:"no" );
		}
		else if ( String::StartsWith( line, "FCOE_ENABLE" ) )
		{
		    return sformat( "FCOE_ENABLE=\"%1\"", netcard["fcoe_enable"]:"yes" );
		}
		else
		{
		    return line;
		}
	    });
	content = mergestring( lines, "\n" );
	y2milestone( "Writing content: %1 to %2", content, file_name );
		
	file_exists = SCR::Write( .target.string, file_name, content );

	if ( file_exists )
	{
	    AddRevertCommand( sformat( "rm %1", file_name ) );
            // fill status map
            status_map = add( status_map, "FCOE_ENABLE", netcard["fcoe_enable"]:"yes");
            status_map = add( status_map, "DCB_REQUIRED", netcard["dcb_required"]:"no");
            status_map = add( status_map, "AUTO_VLAN", netcard["auto_vlan"]:"no");
            status_map = add( status_map, "cfg_device", device_name );
	}
	else
	{
	    y2error( "Cannot create %1", file_name );
	}
    }
    else
    {
	y2error( "Cannot read /etc/fcoe/cfg-ethx" );
    }
    
    return status_map;
}

//
// Get status of FCoE config from /etc/fcoe/cfg-<if>.<vlan> or /etc/fcoe/cfg-<if>
//
global map <string, string> GetFcoeStatus( string vlan_device_name, string device_name )
{
    map <string, string> status_map = $[];
    string content = "";
    boolean file_exists = false;
    string file_name = "";
    string device = vlan_device_name;
    
    if ( vlan_device_name == "" || device_name == "" )
    {
	y2error( "Interface not valid" );
	return $[];
    }

    y2milestone( "Checking configuration for %1", vlan_device_name );

    file_name = sformat( "/etc/fcoe/cfg-%1", vlan_device_name );

    if ( !FileUtils::Exists( file_name ) )
    {
	file_name = sformat( "/etc/fcoe/cfg-%1", device_name );

	if ( !FileUtils::Exists( file_name ) )
	{
            // no config file found - return empty status map
	    return status_map;
	}
	device = device_name;
    }
    // for debugging purpose, read only needed values later 
    list values = SCR::Dir( .fcoe.cfg-ethx.value + device );
    y2milestone( "Available values in %1: %2", file_name, values );
    
    foreach( string var, ["FCOE_ENABLE", "DCB_REQUIRED", "AUTO_VLAN"], {
	    string value = (string)SCR::Read(.fcoe.cfg-ethx.value + device + var);
	    if ( value == nil )
	    {
		y2warning( "Cannot read %1", var );
		continue;
	    }
	    status_map = add( status_map, var, value );
    });

    status_map = add( status_map, "cfg_device", device );

    y2milestone( "Returning: %1", status_map );	

    return status_map;
}

//
// Check whether the network interface (netcard, e.g. eth0 is DCB capable)
//
string DCBCapable( string netcard )
{
    string ret = "no";

    // 'lldpad' must be started to be able to use 'dcbtool'
    // -> is started in ServiceStatus() ( called in Read() before DetectNetworkCards() ) 
    string command = sformat( "LANG=POSIX dcbtool gc %1 dcb", netcard );
    y2milestone( "Executing command: %1", command );

    map output = (map)SCR::Execute( .target.bash_output, command );
    y2milestone( "Output:  %1", output);
    string status = "";
    
    if ( output["exit"]:255 == 0 )
    {
	list <string> lines = splitstring( output["stdout"]:"", "\n" );
	foreach( string line, (list<string>)lines, {
		if ( String::StartsWith( line, "Status" ) )
		{
		    // Status:         Failed		interface not DCB capable
		    // Status:         Successful
		    line = deletechars ( line, " \t:" );
		    status = substring( line, 6 );
		    y2milestone( "Status: %1", status );
		} } );
	if ( status == "Successful" )
	{
	    ret = "yes";
	}
    }
    else
    {
	y2error( "Exit code: %1 Error: %2", output["exit"]:255, output["stderr"]:"" );
    }

    return ret;
}

//
// Set status of services
//
global void AdjustStartStatus( )
{
    boolean fcoe_start = service_start["fcoe"]:false;
    boolean lldpad_start = service_start["lldpad"]:false;
    y2milestone( "Setting start of /etc/init.d/boot.fcoe to %1", fcoe_start );
    y2milestone( "Setting start of /etc/init.d/lldpad to %1", lldpad_start );

    if ( fcoe_start && lldpad_start )
    {
	Service::Enable("boot.lldpad");		// enable 'lldpad' first
	Service::Enable("boot.fcoe");
    }
    else if ( !fcoe_start && lldpad_start )
    {	
	Service::Disable("boot.fcoe");
	Service::Enable("boot.lldpad" );
    }
    else if ( !fcoe_start && !lldpad_start )
    {
	Service::Disable("boot.fcoe");		// disable 'fcoe' first
	Service::Disable("boot.lldpad");
    }
    // fcoe_start && !lldpad_start isn't possible -> see complex.ycp StoreServicesDialog 
}

//
// Set status of services
// 
global void SetStartStatus( string service, boolean status )
{
    y2milestone( "Starting service %1 on boot: %2", service, status );
    service_start[ service ] = status;
}

//
// Get status of services
//
void DetectStartStatus()
{
    boolean status = false;
    
    status = Service::Enabled( "boot.fcoe" );
    y2milestone( "Start status of fcoe: %1", status );
    service_start = add( service_start, "fcoe", status );

    status = Service::Enabled( "boot.lldpad" );
    y2milestone( "Start status of lldpad: %1", status );
    service_start = add( service_start, "lldpad", status );
}

global map<string, boolean> GetStartStatus()
{
    return service_start;
}

//
// Check status of services 'fcoe' and 'lldpad' and start them if required
// 
global boolean ServiceStatus()
{
    boolean success = true;
    
    // Loading of modules in Stage::initial() is not required (like in IsciClientLib.ycp, line 523 )
    // see /etc/init.d/fcoe, line 85 (modprobe fcoe > /dev/null 2>&1)
    boolean ret = true;

    // first start lldpad
    if ( Service::Status( "boot.lldpad" ) != 0 ) 
    {
	success = Service::Start( "boot.lldpad" );
	if ( success )
	{
	    y2milestone( "Lldpad started (/etc/init.d/boot.lldpad start)");
	    lldpad_started = true;
	}
	else
	{
	    y2error( "Cannot start service lldpad - '/etc/init.d/boot.lldpad start' failed" );
	    Report::Error( "Cannot start service lldpad.
'/etc/init.d/boot.lldpad start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "Lldpad service is running");
    }

    if ( Service::Status( "boot.fcoe" ) != 0 )
    {
	success = Service::Start( "boot.fcoe" );
	
	if ( success )
	{
	    y2milestone( "FCoE started (/etc/init.d/boot.fcoe start)");
	    fcoe_started = true;;
	}
	else
	{
	    y2error( "Cannot start FCoE service - '/etc/init.d/boot.fcoe start' failed" );
	    Report::Error( "Cannot start FCoE service.
'/etc/init.d/boot.fcoe start' failed" );
	    ret = false;
	}
    }
    else
    {
	y2milestone( "FCoE service is running");
    }
    
    return ret;
}

//
// Check whether there are configured FCoE VLANs for the given network interface
// Return list of configured VLANs
//
global list IsConfigured( string device_name )
{
    list configured_vlans = [];
    list<map> interfaces = GetNetworkCards();

    foreach ( map interface, interfaces, {
            if ( device_name == interface["dev_name"]:"" &&
                 interface["fcoe_vlan"]:"" != NOT_CONFIGURED &&
                 interface["fcoe_vlan"]:"" != NOT_AVAILABLE )
            {
                configured_vlans = add( configured_vlans, interface["vlan_interface"]:"" );
            }
        } );
    return configured_vlans;
}

// list <map> network_interfaces
//
// dev_name  mac_addr  device      fcoe_vlan  fcoe_enable dcb_required auto_vlan dcb_capable vlan_interface  cfg_file
// eth3      08:00:... Gigabit...  eth3.200   yes/no      yes/no       yes/no    yes/no      200   	     eth3.200
//
// Detect network interface cards (hardware probe) and get status  
//
global boolean DetectNetworkCards()
{
    list <map> netcards = [];

    if ( !TestMode() )
    {
        netcards = (list<map>)SCR::Read(.probe.netcard);
    }
    else        // test data
    {
        netcards = [ $["bus":"PCI", "bus_hwcfg":"pci", "class_id":2, "dev_name":"eth1", "dev_names":["eth1"], "device":"TEST Ethernet Controller", "model":"Intel PRO/1000 MT Desktop Adapter","resource":$["hwaddr":[$["addr":"08:00:27:11:64:e4"]]] ], $["bus":"PCI", "bus_hwcfg":"pci", "class_id":2, "dev_name":"eth15", "dev_names":["eth15"], "device":"TEST Gigabit Ethernet Controller", "model":"Intel PRO/1000 MT Desktop Adapter", "resource":$["hwaddr":[$["addr":"08:23:27:11:64:78"]]]] ];
    }
    y2milestone( "Detected netcards: %1", netcards );
    
    if ( netcards == [] || netcards == nil )
	return false;

    list net_devices = [];
    
    foreach ( map card, netcards, {
	    net_devices = add( net_devices, card["dev_name"]:"" ); 
	});

    // The 'fipvlan' command which is called in GetVlanInterfaces configures the interfaces itself,
    // therefore it's not needed any longer to call 'ifconfig <if> up' here.
    map vlan_info = GetVlanInterfaces( net_devices );

    foreach ( map card, netcards, {
	    map info_map = $[];
	    map <string, string> status_map = $[];
	    string fcoe_vlan_interface = "";
	    string dcb_capable = "";
	    string dcb_default = "";
	    
	    if ( vlan_info[card["dev_name"]:""]:[] == [] )
	    {
		// Interface down or FCoE not enabled on the switch - we can't do anything here.
		fcoe_vlan_interface = NOT_AVAILABLE;

                // add infos about the card
                dcb_capable = DCBCapable( card["dev_name"]:"" );
                info_map = add( info_map, "dcb_capable", dcb_capable ); // DCB capable
                info_map = add( info_map, "dev_name", card["dev_name"]:"");		// network card, e.g. eth3
                info_map = add( info_map, "mac_addr", card["resource", "hwaddr", 0, "addr"]:"" ); // MAC address
                if ( card["device"]:"" != "" )
                {
                    info_map = add( info_map, "device", card["device"]:"");		// device name
                }
                else
                {
                    info_map = add( info_map, "device", card["model"]:"");		// model
                }
                info_map = add( info_map, "fcoe_vlan", fcoe_vlan_interface );	// FCoE VLAN interface, e.g. eth3.200

                network_interfaces = add( network_interfaces, info_map );
	    }
	    else
	    {
                // add infos about card and VLAN interfaces
                list vlans = vlan_info[card["dev_name"]:""]:[];
                foreach ( string vlan, (list<string>) vlans, {

                        if ( vlan == "0" )
                        {
                            // for VLAN interface "0" means start FCoE on network interface (without creating a VLAN
                            // which means there isn't an entry in /proc/net/vlan/config)
                            fcoe_vlan_interface = card["dev_name"]:"";
                        }
                        else    // get FCoE VLAN interface from /proc/net/vlan/config
                        {
                            fcoe_vlan_interface = GetFcoeVlanInterface( card["dev_name"]:"", vlan );
                        }
                        if ( fcoe_vlan_interface != "" )
                        {
                            status_map = GetFcoeStatus( fcoe_vlan_interface, card["dev_name"]:"" );
                            if ( status_map == $[] )
                            {
                                // if a 'fcoe_vlan_interface' is created for a 'vlan' != 0 there should be
                                // a valid configuration available
                                if ( vlan != "0" )
                                {
                                    y2warning( "Cannot read config file for %1 in /etc/fcoe", fcoe_vlan_interface );
                                    Report::Warning( sformat(_("Cannot read config file for %1.
You may edit the settings and recreate the FCoE
VLAN interface to get a valid configuration."), fcoe_vlan_interface) ); 
                                }
                                else    // for vlan == 0 it means FCoE is not (yet) started
                                {
                                    y2milestone( "FCoE not configured" );
                                }
                                // the interface isn't configured
                                fcoe_vlan_interface = NOT_CONFIGURED;
                            }
                            else // add additionally check for VLAN = 0
                            {
                                // is FCoE really configured on interface itself or configured for a VLAN interface?
                                if ( vlan == "0" )
                                {
                                    foreach ( string vlan_cfg_name, (list<string>) vlans, {
                                            // no ifcfg-<if>.<vlan> written for vlan = 0 (see WriteSysconfigFiles() )
                                            if ( FileUtils::Exists( sformat( "/etc/sysconfig/network/ifcfg-%1.%2",
                                                                      card["dev_name"]:"", vlan_cfg_name ) ) )
                                            {
                                                fcoe_vlan_interface = NOT_CONFIGURED;
                                            }
                                        });
                                }
                            }
                        }
                        else
                        {
                            // FCoE VLAN interface not yet configured (status_map remains empty)
                            fcoe_vlan_interface = NOT_CONFIGURED;
                        }
                        dcb_capable = DCBCapable( card["dev_name"]:"" );

                        info_map = add( info_map, "dev_name", card["dev_name"]:"");		// network card, e.g. eth3
                        info_map = add( info_map, "mac_addr", card["resource", "hwaddr", 0, "addr"]:"" ); // MAC address

                        if ( card["device"]:"" != "" )
                        {
                            info_map = add( info_map, "device", card["device"]:"");		// device name
                        }
                        else
                        {
                            info_map = add( info_map, "device", card["model"]:"");		// model
                        }
		
                        info_map = add( info_map, "fcoe_vlan", fcoe_vlan_interface );	// FCoE VLAN interface, e.g. eth3.200

                        // default for FCoE enable is yes
                        info_map = add( info_map, "fcoe_enable", status_map["FCOE_ENABLE"]:"yes" );	// FCOE_ENABLE

                        // exception for Broadcom cards: DCB_REQUIRED should be set to "no" (bnc #728658)
                        if ( (card["driver"]:"" != "bnx2x") && (dcb_capable == "yes") )
                        {
                            dcb_default = "yes";
                        }
                        else
                        {
                            dcb_default = "no";
                        }
                        info_map = add( info_map, "dcb_required", status_map["DCB_REQUIRED"]:dcb_default );

                        // default is AUTO_VLAN="yes", create /etc/fcoe/cfg-ethx file without VLAN device in name
                        // (e.g. /etc/fcoe/cfg-eth3), see bnc #724563
                        info_map = add( info_map, "auto_vlan", status_map["AUTO_VLAN"]:"yes"); // AUTO_VLAN

                        info_map = add( info_map, "dcb_capable", dcb_capable ); // DCB capable
                        info_map = add( info_map, "vlan_interface", vlan ); // VLAN interface, e.g. 200
                        info_map = add( info_map, "cfg_file", status_map["cfg_device"]:"" ); // part of cfg-file name, e.g. eth3.200
                        network_interfaces = add( network_interfaces, info_map );
                        
                    });
            } //else

	} );
     
    // sort the list of interfaces (eth0, eth1, eth2...)
    network_interfaces = sort( map a, map b, network_interfaces, {
		    return ( a["dev_name"]:"" < b["dev_name"]:"" );
	} );

    return true;
}

//
// Read /etc/fcoe/config
//
global boolean ReadFcoeConfig()
{
    list <string> options = (list<string>) SCR::Dir(.fcoe.config);
    y2milestone( "List of options in /etc/fcoe/config: %1", options );

    if ( options == [] || options == nil )
	return false;
    
    string debug_val = (string)SCR::Read(add(.fcoe.config, "DEBUG"));
    fcoe_general_config = add( fcoe_general_config, "DEBUG", debug_val );
	
    string syslog_val = (string)SCR::Read(add(.fcoe.config, "USE_SYSLOG"));
    fcoe_general_config = add( fcoe_general_config, "USE_SYSLOG", syslog_val );

    y2milestone( "/etc/fcoe/config read: DEBUG: %1, USE_SYSLOG: %2", debug_val, syslog_val );
    
    return true;
}

//
// Write /etc/fcoe/config using fcoe_config.scr
//
global boolean WriteFcoeConfig()
{
    boolean success = (boolean)SCR::Write(add(.fcoe.config, "DEBUG"), GetFcoeConfig()["DEBUG"]:"" );
    if ( !success )
	return false;

    success = (boolean)SCR::Write(add(.fcoe.config, "USE_SYSLOG"), GetFcoeConfig()["USE_SYSLOG"]:"" );	
    if ( !success )
	return false;

    // This is very important- it flushes the cache, and stores the configuration on the disk
    success = SCR::Write(.fcoe.config, nil);

    return success;
}

//
// Write ifcfg-files in /etc/sysconfig/network (for FCoE VLAN interface and underlying interface)
// using network.scr from yast2/library/network
//
global boolean WriteSysconfigFiles( )
{
    list <map> netcards = GetNetworkCards();
    boolean success = true;

    foreach ( map card, (list<map>)netcards, {
	    if ( card["fcoe_vlan"]:"" != FcoeClient::NOT_AVAILABLE &&		// FCoE VLAN is configured
		 card["fcoe_vlan"]:"" != FcoeClient::NOT_CONFIGURED  )
	    {
                // write ifcfg-<if>.>VLAN> only if VLAN was created (not for VLAN = 0 which means
                // FCoE is started on the network interface itself)
                if ( card["vlan_interface"]:"" != "0" )
                {
                    y2milestone( "Writing /etc/sysconfig/network/ifcfg-%1", card["fcoe_vlan"]:"" );
                    // write /etc/sysconfig/network/ifcfg-<fcoe-vlan-interface>, e.g. ifcfg-eth3.200
                    SCR::Write(.network.value + card["fcoe_vlan"]:"" + "BOOTPROTO", "static" );
                    SCR::Write(.network.value + card["fcoe_vlan"]:"" + "STARTMODE", "nfsroot" );
                    SCR::Write(.network.value + card["fcoe_vlan"]:"" + "ETHERDEVICE", card["dev_name"]:"" );
                    SCR::Write(.network.value + card["fcoe_vlan"]:"" + "USERCONTROL", "no" );
                }
		string ifcfg_file = sformat( "/etc/sysconfig/network/ifcfg-%1", card["dev_name"]:"" );
		y2milestone( "Writing %1", ifcfg_file );
		
		// write /etc/sysconfig/network/ifcfg-<interface> (underlying interface), e.g. ifcfg-eth3
		if ( !FileUtils::Exists(ifcfg_file) )
		{
		    SCR::Write(.network.value + card["dev_name"]:"" + "BOOTPROTO", "static" );
		    SCR::Write(.network.value + card["dev_name"]:"" + "STARTMODE", "nfsroot" );
		    SCR::Write(.network.value + card["dev_name"]:"" + "NAME", card["device"]:"" );
		}
		else
		{
		    // don't overwrite BOOTPROTO !!!
		    SCR::Write(.network.value + card["dev_name"]:"" + "STARTMODE", "nfsroot" );
		}
	    }
	} );
    // This is very important- it flushes the cache, and stores the configuration on the disk
    success = SCR::Write( .network, nil );
    if ( !success )
    {
	y2error( "Error writing /etc/sysconfig/network/ifcfg-files" );
    }
    return success;
}

//
// Write /etc/fcoe/cfg-ethx files using fcoe_cfg-ethx.scr
//
global boolean WriteCfgFiles()
{
    list <map> netcards = GetNetworkCards();

    boolean success = false;
    
    foreach ( map card, (list<map>)netcards, {
	    if ( card["fcoe_vlan"]:"" != FcoeClient::NOT_AVAILABLE &&			// FCoE VLAN is configured
		 card["fcoe_vlan"]:"" != FcoeClient::NOT_CONFIGURED )
	    {
		string command = "";
		map output = $[];

		y2milestone( "Writing /etc/fcoe/cfg-%1", card["cfg_file"]:"" );
		success = SCR::Write(.fcoe.cfg-ethx.value + card["cfg_file"]:"" + "FCOE_ENABLE", card[ "fcoe_enable"]:"no" );
		if ( !success )
		{
		    y2error( "Writing FCOE_ENABLE=%1 failed", card[ "fcoe_enable"]:"no" );
		}
		success = SCR::Write(.fcoe.cfg-ethx.value + card["cfg_file"]:"" + "DCB_REQUIRED", card["dcb_required"]:"no" );
		if ( !success )
		{
		    y2error( "Writing DCB_REQUIRED=%1 failed", card["dcb_required"]:"no" );
		}
		success = SCR::Write(.fcoe.cfg-ethx.value + card["cfg_file"]:"" + "AUTO_VLAN", card["auto_vlan"]:"no" );
		if ( !success )
		{
		    y2error( "Writing AUTO_VLAN=%1 failed", card["auto_vlan"]:"no" );
		}
		if ( card["dcb_required"]:"no" == "yes" )
		{
		    // enable DCB on the interface
		    command = sformat( "dcbtool sc %1 dcb on", card["dev_name"]:"" );
		    y2milestone( "Executing command: %1", command );
		    output = (map)SCR::Execute( .target.bash_output, command );
		    y2milestone( "Output: %1", output );
		    if ( output["exit"]:255 != 0 )
		    {
			// only warning, not necessarily an error
			y2warning( "Command: %1 failed", command);
		    }
		    // enable App:FCoE on the interface
		    command = sformat( "dcbtool sc %1 app:0 e:1 a:1 w:1", card["dev_name"]:"" );
		    y2milestone( "Executing command: %1", command );

		    output = (map)SCR::Execute( .target.bash_output, command );
		    y2milestone( "Output: %1", output );
		    if ( output["exit"]:255 != 0 )
		    {
			// only warning, not necessarily an error
			y2warning( "Command: %1 failed", command);
		    } 
		}
	    }
	} );
    // This is very important- it flushes the cache, and stores the configuration on the disk
    success = SCR::Write( .fcoe.cfg-ethx, nil );
    
    return success;
}

// restart service fcoe
global boolean RestartServiceFcoe()
{
    boolean ret = true;

    y2milestone( "Restarting fcoe");
    ret = Service::Restart("boot.fcoe");

    return ret;
}

/**
 * Read all fcoe-client settings
 * @return true on success
 */
global boolean Read()
{

    /* FcoeClient read dialog caption */
    string caption = _("Initializing fcoe-client Configuration");

    // Set the right number of stages
    integer steps = 4;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
					 /* Progress stage 1/3 */
					 _("Check installed packages"),
					 /* Progress stage 2/3 */
					 _("Check services"),
					 /* Progress stage 3/3 */
					 _("Detect network cards"),
					 /* Progress stage 4/4 */
					 _("Read /etc/fcoe/config")
					 ], [
					     /* Progress step 1/3 */
					     _("Checking for installed packages..."),
					     /* Progress step 2/3 */
					     _("Checking for services..."),
					     /* Progress step 3/3 */
					     _("Detecting network cards..."),
					     /* Progress step 4/4 */
					     _("Reading /etc/fcoe/config"),
					     /* Progress finished */
					     _("Finished")
					     ],
		   ""
		   );

    // a check for running network services doesn't make sense (is not needed), the
    // interfaces are set up in FcoeClient::GetVlanInterfaces()
     
    if(PollAbort()) return false;
    Progress::NextStage();

    // checking whether open-fcoe is installed (requires lldpad, ...)
    boolean installed = CheckInstalledPackages();
    
    /* Error message */
    if( !installed ) return false;
    sleep(sl);

    // read current settings
    if(PollAbort()) return false;
    Progress::NextStage();

    // check whether auto start of daemon fcoemon and lldpad is enabled or not
    DetectStartStatus();
    // check whether fcoe and lldpad are running and start services if required
    boolean start_status = ServiceStatus();
    
    /* Error message */
    if(!start_status) Report::Error(_("Starting of services failed."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();

    // detect netcards
    boolean success = DetectNetworkCards();
    
    /* Error message */
    if( !success ) Report::Warning(_("Cannot detect devices."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();

    // read general FCoE settings
    success = ReadFcoeConfig();
    
    /* Error message */
    if( !success ) Report::Error(_("Cannot read /etc/fcoe/config."));
    sleep(sl);
    
    Progress::Finish();
    
    if(PollAbort()) return false;
    // modified = false is from CWM template
    modified = false;

    return true;
}

/**
 * Write all fcoe-client settings
 * @return true on success
 */
global boolean Write()
{

    /* FcoeClient read dialog caption */
    string caption = _("Saving fcoe-client Configuration");
    y2milestone( "Saving fcoe-client Configuration" );
    
    // Set the number of stages
    integer steps = 3;

    integer sl = 500;
    
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
					/* Progress stage 1/2 */
					_("Write the settings"),
					/* Progress stage 2/3 */
					_("Restart FCoE service"),
					/* Progress stage 3/3 */
					_("Adjust start of services")
					], [
					    /* Progress step 1/2 */
					    _("Writing the settings..."),
					    /* Progress step 2/3 */
					    _("Restarting FCoE service..."),
					    /* Progress sstep 3/3 */
					    _("Adjusting start of services..."),
					    /* Progress finished */
					    _("Finished")
					    ],
		  ""
		  );

    // iscsi-client prepares for AutoYaST in Mode::autoinst()/autoupgrade()
    // (see IscsiClient.ycp, line 236, 241)
    // These things are done in fcoe-client_auto.ycp (should be sufficient there)
    
    boolean is_running = Progress::IsRunning();
    y2debug( "**** Progress still running: %1", is_running );

    // write settings
    if(PollAbort()) return false;
    Progress::NextStage();
    
    boolean success = WriteFcoeConfig();
    /* Error message */
    if( !success ) Report::Error (_("Cannot write settings to /etc/fcoe/config."));
    sleep(sl);

    success = WriteCfgFiles();
    if( !success ) Report::Error (_("Cannot write settings for FCoE interfaces.
For details, see /var/log/YaST2/y2log.") );

    if(PollAbort()) return false;
    Progress::NextStage();

    // restart fcoe to enable changes 
    success = RestartServiceFcoe();
     /* Error message */
    if( !success ) Report::Error (_("Restarting of service fcoe failed."));
    sleep(sl);

    // write ifcfg-files in /etc/sysconfig/network
    success = WriteSysconfigFiles();
    /* Error message */
    if( !success ) Report::Error (_("Cannot write /etc/sysconfig/network/ifcfg-files."));
    sleep(sl);
    
    if(PollAbort()) return false;
    Progress::NextStage ();

    // adjust start status of services lldpad and fcoe
    AdjustStartStatus();

    // Adding additional package (like in IscsiClient.ycp, line 257)
    // is done in inst_fcoe-client.ycp (PackagesProposal::AddResolvables)
    sleep(sl);

    if(PollAbort()) return false;

    return true;
}

/**
 * Get all fcoe-client settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings)
{
    // fill variables
    fcoe_general_config = (map <string, string>)settings["fcoe_cfg"]:$[ ];
    network_interfaces = (list <map>)settings["interfaces"]:[];
    service_start = (map <string, boolean>)settings["service_start"]:$[ ];
    
    SetModified( true );
    y2milestone ("Configuration has been imported");

    return true;
}

/**
 * Dump the fcoe-client settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export ()
{
    // return map containing current settings 
    return $[
             "fcoe_cfg" : fcoe_general_config,
             "interfaces" : network_interfaces,
	     "service_start" : service_start
             ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary()
{
    string summary = "";
    map fcoe_config = $[];
    list <map> netcards = [];
    map service_start = $[];
    
    /* Configuration summary text for autoyast */
    summary = Summary::AddLine( summary, _("<b>General FCoE configuration</b>") );
    fcoe_config = FcoeClient::GetFcoeConfig();
    // options from config file, not meant for translation 
    summary = Summary::AddLine( summary, sformat( "DEBUG: %1", fcoe_config["DEBUG"]:"" ) );
    summary = Summary::AddLine( summary, sformat( "USE_SYSLOG: %1", fcoe_config["USE_SYSLOG"]:"" ) );
    summary = Summary::AddLine( summary, _("<b>Interfaces</b>") );
    netcards = FcoeClient::GetNetworkCards();
    foreach ( map card, netcards, {
	    summary = Summary::AddLine( summary, sformat( "%1: %2 %3: %4",
							  // network card, e.g. eth0
							  _("<i>Netcard</i>:"), card["dev_name"]:"",
							  // nothing to translate here (abbreviation for
							  // Fibre Channel over Ethernet Virtual LAN interface)
							  "<i>FCoE VLAN</i>", card["fcoe_vlan"]:"" ) );
	} );
    service_start = FcoeClient::GetStartStatus();
    summary = Summary::AddLine( summary, _("<b>Starting of services</b>") );
    
    // starting of service "fcoe" at boot time is enabled or disabled
    summary = Summary::AddLine( summary, sformat( "fcoe: %1", (service_start["fcoe"]:false)?_("enabled"):_("disabled") ));
    // starting of service "lldpad" at boot time is enabled or disabled 
    summary = Summary::AddLine( summary, sformat( "lldpad: %1", (service_start["lldpad"]:false)?_("enabled"):_("disabled") ) );
    
    return [ summary, [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages()
{
    // installation of open-fcoe required
    return $[ "install":["open-fcoe"], "remove":[] ];
}

/* EOF */
}
